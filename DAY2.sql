
-- ORDER BY (BY DEFAULT ASC)
SELECT * FROM STAFFS 
ORDER BY STAFF_NAME ASC;

-- NULL VALUES COME FIRST
SELECT * FROM STAFFS 
ORDER BY STAFF_EMAIL;

-- ORDER BY MULTIPLE COLUMNS
SELECT * FROM STAFFS
ORDER BY GENDER DESC, STAFF_NAME DESC;

SELECT * FROM STAFFS
ORDER BY EMPLOYMENT_DATE DESC;

-- EXAMPLE 1: GROUP BY + HAVING (AGG FUNCTIONS)
SELECT GENDER, SUM(SALARY) AS SUM_OF_SALARY
FROM STAFFS
WHERE STAFF_NAME LIKE '%LAU' -- FILTER DATA (BEFORE GROUP BY)
GROUP BY GENDER
HAVING COUNT(1) > 1; -- FILTER GROUP

-- RESULT
-- M 51500.00

-- EXPLAINATION OF THE ABOVE:
-- STEP 1: FILTER DATA (BEFORE GROUP)
SELECT 'HELLO', S.*
FROM STAFFS S
WHERE S.STAFF_NAME LIKE '%LAU';

-- STEP 2: 
SELECT GENDER, SUM(SALARY) AS SUM_OF_SALARY
FROM STAFFS
WHERE STAFF_NAME LIKE '%LAU'
GROUP BY GENDER;

-- STEP 3: YOU CAN USE HAVING TO DETERMINE WHICH GROUP SHOULD EXIST
SELECT GENDER, SUM(SALARY) AS SUM_OF_SALARY
FROM STAFFS
WHERE STAFF_NAME LIKE '%LAU'
GROUP BY GENDER
HAVING COUNT('HELLO') > 1;

-- EXAMPLE 2: GROUP BY + HAVING
SELECT DEPT_CODE, SUM(SALARY) AS SUM_OF_SALARY, MIN(SALARY), AVG(SALARY) -- STAFF_NAME
FROM STAFFS
GROUP BY DEPT_CODE
HAVING MIN(SALARY) < 21000; -- FILTER OUT DEPT_CODE 'HR', BECAUSE MIN SALARY OF HR DEPARTMENT >= 21000

-- CASE WHEN THEN ELSE (JAVA: IF ELSE IF)
SELECT CASE
		WHEN DEPT_CODE = 'IT' THEN 'INFORMATION TECHNOLOGY'
        WHEN DEPT_CODE = 'HR' THEN 'HUMAN RESOURCE'
		WHEN DEPT_CODE = 'MK' THEN 'MARKETING'
        ELSE 'N/A'
	   END AS 'DEPT_DESCRIPTION'
,      CASE
		 WHEN SALARY > 30000 THEN 'H'
         WHEN SALARY > 20000 THEN 'M'
         ELSE 'S'
	   END AS 'SALARY_GROUP'
, STAFF_NAME, SALARY
FROM STAFFS;

-- DISTINCT (SHOW ALL POSSIBLE VALUES)
-- "DISTINCT GENDER, DEPT_CODE" -> DISTINCT 2 COLUMNS
-- YOU SHOULD NOT USE AGG FUNCTION WITH DISTINCT 
SELECT DISTINCT GENDER, DEPT_CODE
FROM STAFFS;

-- GROUP BY 2 COLUMNS
SELECT GENDER, DEPT_CODE, SUM(SALARY), MAX(SALARY)
FROM STAFFS
GROUP BY GENDER, DEPT_CODE; -- ONE GROUP DEFINTION

-- DROP TABLE ORDERS;
-- create table ORDERS with datetime
CREATE TABLE ORDERS (
	ID INTEGER,
    ORDER_DATETIME DATETIME,
    COUPON_CODE VARCHAR(10),
    ORDER_STATUS VARCHAR(1)
);

INSERT INTO ORDERS VALUES (1, STR_TO_DATE('2023-01-01 00:00:00', '%Y-%m-%d %T'), NULL, 'P');
INSERT INTO ORDERS VALUES (2, '2024-12-31 18:05:23', NULL, 'P');

-- LIMIT + ORDER BY
SELECT *
FROM STAFFS 
ORDER BY SALARY DESC
LIMIT 2; -- FIRST 2 ROWS OF THE RESULT SET AFTER ORDER BY

-- JOIN
CREATE TABLE NUMBERS (
	NUMBER1 INTEGER,
    NUMBER2 INTEGER
);
-- 3 x 2
INSERT INTO NUMBERS VALUES (1, 10);
INSERT INTO NUMBERS VALUES (2, 105);
INSERT INTO NUMBERS VALUES (3, 299);

CREATE TABLE NAMES(
	NAME1 VARCHAR(10),
    NAME2 VARCHAR(10),
	NUM INTEGER
);
-- 3 x 3
INSERT INTO NAMES VALUES ('JOHN', 'PETER', 2);
INSERT INTO NAMES VALUES ('JENNY', 'SALLY', 1);
INSERT INTO NAMES VALUES ('STEVEN', 'OSCAR', 4);

-- INNER JOIN (WITHOUT CONDITION)
-- Usage: Find out all combinations
-- 9 x 5 (9 = 3 x 3, 5 columns)
SELECT R.*, N.*
FROM NUMBERS R INNER JOIN NAMES N;

-- SELF INNER JOIN
SELECT R.*, N.*
FROM NUMBERS R INNER JOIN NAMES N ON R.NUMBER1 = N.NUM;

-- INNER JOIN: DEPARTMENTS + STAFFS 
-- ONE TO MANY: ONE STAFF BELONGS TO ONE DEPT, BUT ONE DEPT MAY HAVE MORE THAN ONE STAFF
CREATE TABLE DEPARTMENTS (
	ID INTEGER,
    DEPT_CODE VARCHAR(2),
    DEPT_DESC VARCHAR(100)
);
INSERT INTO DEPARTMENTS VALUES (1, 'IT', 'INFORMATION TECHNOLOGY');
INSERT INTO DEPARTMENTS VALUES (2, 'HR', 'HUMAN RESOURCES');
INSERT INTO DEPARTMENTS VALUES (3, 'MK', 'MARKETING');

-- INNER JOIN + ORDER BY
SELECT D.DEPT_DESC, S.STAFF_NAME, S.SALARY
FROM DEPARTMENTS D INNER JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
ORDER BY S.DEPT_CODE, S.SALARY DESC;

-- INNER JOIN + GROUP BY
SELECT D.DEPT_CODE, SUM(S.SALARY) AS DEPT_TOTAL_SALARY
FROM DEPARTMENTS D INNER JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
GROUP BY D.DEPT_CODE
ORDER BY DEPT_TOTAL_SALARY DESC; -- last step of SQL

-- LEFT JOIN (WITHOUT GROUP)
SELECT D.*, S.*
FROM DEPARTMENTS D LEFT JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE;


-- LEFT JOIN
INSERT INTO DEPARTMENTS VALUES (4, 'CS', 'CUSTOMER SERVICE');
-- CS DEPARTMENT HAS NO STAFF
SELECT D.DEPT_CODE, COUNT(S.ID) DEPT_STAFF_NUMBER
FROM DEPARTMENTS D LEFT JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
GROUP BY D.DEPT_CODE;

-- RIGHT JOIN (same result as the above)
SELECT D.DEPT_CODE, COUNT(S.ID) DEPT_STAFF_NUMBER
FROM STAFFS S RIGHT JOIN DEPARTMENTS D ON D.DEPT_CODE = S.DEPT_CODE
GROUP BY D.DEPT_CODE;

-- LEFT JOIN (WITHOUT INTERSECT)
SELECT D.DEPT_CODE, COUNT(S.ID) DEPT_STAFF_NUMBER
FROM DEPARTMENTS D LEFT JOIN STAFFS S ON D.DEPT_CODE = S.DEPT_CODE
WHERE S.ID IS NULL
GROUP BY D.DEPT_CODE;

-- EXISTS/ NOT EXISTS (YOU HAVE TO USE A KEY TO MAP)
-- FIND THE DEPARTMENT WHICH HAS NO STAFF
-- DISADVANTAGE: YOU CANNOT SELECT COLUMN IN TABLE STAFF
SELECT D.*
FROM DEPARTMENTS D
WHERE NOT EXISTS (SELECT 1 FROM STAFFS S WHERE D.DEPT_CODE = S.DEPT_CODE);

SELECT D.*
FROM DEPARTMENTS D
WHERE EXISTS (SELECT 1 FROM STAFFS S WHERE D.DEPT_CODE = S.DEPT_CODE);